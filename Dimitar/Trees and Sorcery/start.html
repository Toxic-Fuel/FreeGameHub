<!DOCTYPE html>
<!-- code.zip 2020 -->
<html>

<head>
    <style>
        body,
        canvas {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta charset="UTF-8">
    </meta> <!-- allows for cyrillic and other exotic text in console.logs -->
</head>

<body onload="onBodyLoad()">
    <canvas id="canvas-id" width="800" height="600">
        <script>
            // How often will the update function from game.js be executed
            let updateTime;

            // Create global variables
            let mouseX, mouseY, key_left, key_up, key_right, key_down, key_a, key_z, isKeyPressed;

            // More global variables
            let canvas, context;

            // Fullscreen flag
            let endlessCanvas = true;

            // Access to functions, created in game.js
            var update, draw, mouseup, mousemove, mousedown, keyup, keydown, init;

            const reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                setTimeout(callback, 1000 / 30);
            };


            // Custom image class - sets imgObj.img.src after imgObj.draw() has been called
            class MyImage {
                constructor(src_, backupColor_) {
                    this.src = src_;
                    this.backupColor = backupColor_;

                    // Create image object with no source path
                    this.img = new Image();
                    this.canDraw = false;
                    this.drawBackup = false;

                    this.img.onload = () => {
                        this.canDraw = true;
                    }
                    this.img.onerror = () => {
                        this.canDraw = false;
                        this.drawBackup = true;
                        throw "Unable to load image " + this.src;
                    }

                }
                draw(x, y, xs, ys) {
                    if (xs == undefined) {
                        xs = this.img.width | 100;
                        ys = this.img.height | 100;
                    }
                    // If img.src is undefined - set it
                    if (!this.img.src) {
                        // Load image
                        this.img.src = this.src;
                    } else if (this.canDraw) {
                        try {
                            context.drawImage(this.img, x, y, xs, ys);
                        } catch (e) {
                            this.canDraw = false;
                            this.drawBackup = true;
                            throw e;
                        }
                    } else if (this.drawBackup) {
                        context.fillStyle = this.backupColor;
                        context.fillRect(x, y, xs, ys);
                    }
                }
            }


            // Attach image objects to global scope
            (function preloadImages() {
                // Load all images from ./images folder "BY HAND"
                const imageObjectList = [
                { imageName: 'ancientCrystal[0]', backupColor: 'aqua' }, { imageName: 'ancientCrystal[1]', backupColor: 'aqua' },
                { imageName: 'ancientCrystal[2]', backupColor: 'aqua' }, { imageName: 'ancientCrystal[3]', backupColor: 'aqua' },
                { imageName: 'ancientCrystal[4]', backupColor: 'aqua' }, { imageName: 'ancientCrystal[5]', backupColor: 'aqua' },
                { imageName: 'backDarkForest', backupColor: 'green' }, { imageName: 'druidAttack1[0]', backupColor: 'green' },
                { imageName: 'druidAttack1[1]', backupColor: 'green' }, { imageName: 'druidAttack1[2]', backupColor: 'green' },
                { imageName: 'druidAttack1[3]', backupColor: 'green' }, { imageName: 'druidAttack1[4]', backupColor: 'green' },
                { imageName: 'druidAttack2[0]', backupColor: 'green' }, { imageName: 'druidAttack2[1]', backupColor: 'green' },
                { imageName: 'druidAttack2[2]', backupColor: 'green' }, { imageName: 'druidAttack2[3]', backupColor: 'green' },
                { imageName: 'druidAttack2[4]', backupColor: 'green' }, { imageName: 'druidAttack2[5]', backupColor: 'green' },
                { imageName: 'druidAttack2[6]', backupColor: 'green' }, { imageName: 'druidAttack3[0]', backupColor: 'green' },
                { imageName: 'druidAttack3[1]', backupColor: 'green' }, { imageName: 'druidAttack3[2]', backupColor: 'green' },
                { imageName: 'druidAttack3[3]', backupColor: 'green' }, { imageName: 'druidAttack3[4]', backupColor: 'green' },
                { imageName: 'druidAttack3[5]', backupColor: 'green' }, { imageName: 'druidAttack3[6]', backupColor: 'green' },
                { imageName: 'druidAttack4[0]', backupColor: 'green' }, { imageName: 'druidAttack4[1]', backupColor: 'green' },
                { imageName: 'druidAttack4[2]', backupColor: 'green' }, { imageName: 'druidAttack4[3]', backupColor: 'green' },
                { imageName: 'druidAttack4[4]', backupColor: 'green' }, { imageName: 'fireballBig[0]', backupColor: 'red' },
                { imageName: 'enemyDeath[0]', backupColor: 'orange'}, { imageName: 'enemyDeath[1]', backupColor: 'orange'},
                { imageName: 'enemyDeath[2]', backupColor: 'orange'}, { imageName: 'enemyDeath[3]', backupColor: 'orange'},
                { imageName: 'enemyDeath[4]', backupColor: 'orange'}, { imageName: 'fireballBig[1]', backupColor: 'red' },
                { imageName: 'fireballBig[2]', backupColor: 'red' }, { imageName: 'fireballBig[3]', backupColor: 'red' }, 
                { imageName: 'fireballBig[4]', backupColor: 'red' }, { imageName: 'fireballBig[7]', backupColor: 'red' },
                { imageName: 'fireballBig[8]', backupColor: 'red' }, { imageName: 'fireballBig[9]', backupColor: 'red' },
                { imageName: 'fireballBig[10]', backupColor: 'red' }, { imageName: 'fireballBig[11]', backupColor: 'red' },
                { imageName: 'fireballMedium[0]', backupColor: 'red' }, { imageName: 'fireballMedium[1]', backupColor: 'red'},
                { imageName: 'fireballMedium[2]', backupColor: 'red' }, { imageName: 'fireballMedium[3]', backupColor: 'red'},
                { imageName: 'fireballMedium[4]', backupColor: 'red' }, { imageName: 'fireballMedium[5]', backupColor: 'red'},
                { imageName: 'fireballMedium[6]', backupColor: 'red' }, { imageName: 'fireballMedium[7]', backupColor: 'red'},
                { imageName: 'fireballMedium[8]', backupColor: 'red' }, { imageName: 'fireballMedium[9]', backupColor: 'red'},
                { imageName: 'fireballMedium[10]', backupColor: 'red' }, {imageName: 'fireballMedium[11]', backupColor: 'red'},
                { imageName: 'fireballSmall[0]', backupColor: 'red' }, { imageName: 'fireballSmall[1]', backupColor: 'red' },
                { imageName: 'fireballSmall[2]', backupColor: 'red' }, { imageName: 'fireballSmall[3]', backupColor: 'red' },
                { imageName: 'fireballSmal[4]', backupColor: 'red' }, { imageName: 'fireballSmall[5]', backupColor: 'red' },
                { imageName: 'fireballSmall[6]', backupColor: 'red' }, { imageName: 'fireballSmall[7]', backupColor: 'red' },
                { imageName: 'fireballSmall[8]', backupColor: 'red' }, { imageName: 'fireballSmall[9]', backupColor: 'red' },
                { imageName: 'fireballSmall[10]', backupColor: 'red'}, { imageName: 'fireballSmall[11]', backupColor: 'red' },
                { imageName: 'monkeyDown[0]', backupColor: 'brown' }, { imageName: 'monkeyDown[1]', backupColor: 'brown' },
                { imageName: 'monkeyDown[2]', backupColor: 'brown' }, { imageName: 'monkeyDown[3]', backupColor: 'brown' },
                { imageName: 'monkeyLeft[0]', backupColor: 'brown' }, { imageName: 'monkeyLeft[1]', backupColor: 'brown' },
                { imageName: 'monkeyLeft[2]', backupColor: 'brown' }, { imageName: 'monkeyLeft[2]', backupColor: 'brown' },
                { imageName: 'monkeyLeft[3]', backupColor: 'brown' }, { imageName: 'monkeyRight[0]', backupColor: 'brown' },
                { imageName: 'monkeyRight[1]', backupColor: 'brown' }, { imageName: 'monkeyRight[2]', backupColor: 'brown' },
                { imageName: 'monkeyRight[3]', backupColor: 'brown' }, { imageName: 'monkeyStand[0]', backupColor: 'brown' },
                { imageName: 'monkeyStand[1]', backupColor: 'brown' }, { imageName: 'monkeyStand[2]', backupColor: 'brown' },
                { imageName: 'monkeyStand[3]', backupColor: 'brown' }, { imageName: 'monkeyUp[0]', backupColor: 'brown' },
                { imageName: 'monkeyUp[1]', backupColor: 'brown' }, { imageName: 'monkeyUp[2]', backupColor: 'brown' },
                { imageName: 'monkeyUp[3]', backupColor: 'brown' }, { imageName: 'rune', backupColor: 'blue'},
                { imageName: 'skeletonWalk[0]', backupColor: 'brown' }, { imageName: 'skeletonWalk[1]', backupColor: 'brown' },
                { imageName: 'skeletonWalk[2]', backupColor: 'brown' }, { imageName: 'skeletonWalk[3]', backupColor: 'brown' },
                { imageName: 'skeletonWalk[4]', backupColor: 'brown' }, { imageName: 'skeletonWalk[5]', backupColor: 'brown' },
                { imageName: 'skeletonWalk[6]', backupColor: 'brown' }, { imageName: 'skeletonWalk[7]', backupColor: 'brown' },];

                // For each element of array - create a global variable
                for (let i = 0; i < imageObjectList.length; i++) {
                    let name = imageObjectList[i].imageName,
                        backupColor = imageObjectList[i].backupColor;

                    // Handle image names like "gosho[21]"
                    if (name.indexOf("[") > -1) {
                        let arrayName = name.slice(0, name.indexOf("["));
                        let arrayNumber = name.slice(name.indexOf("[") + 1, name.indexOf("]"));
                        if (!window[arrayName]) {
                            window[arrayName] = [];
                        }
                        window[arrayName][arrayNumber] = tryToLoad(name, backupColor);
                    } else {
                        // Handle image names like "pesho"
                        window[name] = tryToLoad(name, backupColor);
                    }
                }
            }());

            function drawImage(myImageObject, x, y, xs, ys) {
                myImageObject.draw(x, y, xs, ys);
            }

            function isFunction(f) {
                return typeof (f) == "function";
            }

            function areColliding(Ax, Ay, Awidth, Aheight, Bx, By, Bwidth, Bheight) {
                if (Bx <= Ax + Awidth) {
                    if (Ax <= Bx + Bwidth) {
                        if (By <= Ay + Aheight) {
                            if (Ay <= By + Bheight) {
                                return 1;
                            }
                        }
                    }
                }
                return 0;
            };

            function randomInteger(upTo) {
                return Math.floor(Math.random() * upTo);
            }

            function drawLine(startX, startY, endX, endY) {
                // For better performance bunch calls to lineTo without beginPath() and stroke() inbetween.
                context.beginPath(); // resets the current path
                context.moveTo(startX, startY);
                context.lineTo(endX, endY);
                context.stroke();
            }

            function drawCircle(centerX, centerY, radius, color, color2) {
                context.beginPath();
                context.fillStyle = color;
                context.strokeStyle = color2;
                context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                context.fill();
                context.stroke();
            }

            function drawPi6ka(aX, aY, aR, aC, aB) {
                drawCircle(aX, aY, circle.r, aC, aB);
                drawCircle(aX + 55, aY, circle.r, aC, aB);
                context.fillRect(aX - 3, aY - 150, 60, 150);
                drawCircle(aX + 27.5, aY - 150, 30);
                drawLine(aX - 3, aY - aR + 1, aX - 2, aY - 150);
                drawLine(aX + 57, aY - aR + 1, aX + 58, aY - 150);
                drawLine(aX + 27.5, aY - 150, aX + 27.5, aY - 180);

            }

            function KURsor(aX, aY, aR, aC, aB) {
                drawPi6ka(aX, aY, aR, aC, aB);
                circle.x += (mouseX - circle.x) / 10 - 2.5;
                circle.y += (mouseY - circle.y) / 10;
            }

            function updateMousePosition(e) {
                let boundingRect = canvas.getBoundingClientRect();
                mouseX = e.pageX - boundingRect.x;
                mouseY = e.pageY - boundingRect.y;
            }

            function updateMousePositionTouchEvent(e) {
                let boundingRect = canvas.getBoundingClientRect();
                let touchobj = e.changedTouches[0];
                mouseX = touchobj.pageX - boundingRect.x;
                mouseY = touchobj.pageY - boundingRect.y;
            }

            function getCanvas() {
                // Get canvas element
                canvas = document.getElementById("canvas-id");

                if (endlessCanvas) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // Change canvas.width and .height on browser resize
                    window.onresize = function () {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                } else {
                    // Default canvas size
                    canvas.width = 800;
                    canvas.height = 600;
                }

                // Get 2d context
                context = canvas.getContext("2d");
                context.fillStyle = "#0000ff";
            }

            function attachEvents() {
                // Events for touchscreen devices
                if ('ontouchstart' in window || navigator.maxTouchPoints) {
                    isMobile = true;
                    window.addEventListener("touchstart", function (e) {
                        // Update global mouseX, mouseY variables
                        updateMousePositionTouchEvent(e);
                        if (isFunction(mousedown)) {
                            // Call mousedown from game.js if it exists
                            mousedown();
                        }
                    });
                    window.addEventListener("touchend", function (e) {
                        updateMousePositionTouchEvent(e);
                        if (isFunction(mouseup)) {
                            mouseup();
                        }
                    });
                    window.addEventListener("touchmove", function (e) {
                        updateMousePositionTouchEvent(e);
                    });
                }

                // Update global mouseX, mouseY variables
                window.addEventListener("mousemove", function (e) {
                    updateMousePosition(e);
                });

                // Call mousemove, mouseup, mousedown function from game.js if they exist
                if (isFunction(mousemove)) {
                    window.addEventListener("mousemove", mousemove);
                }
                if (isFunction(mouseup)) {
                    window.addEventListener("mouseup", mouseup);
                }
                if (isFunction(mousedown)) {
                    window.addEventListener("mousedown", mousedown);
                }

                // Update global isKeyPressed array
                window.addEventListener("keydown", function (e) {
                    isKeyPressed[e.keyCode] = 1;
                    if (isFunction(keydown)) {
                        keydown(e.keyCode);
                    }
                });
                window.addEventListener("keyup", function (e) {
                    isKeyPressed[e.keyCode] = 0;
                    if (isFunction(keyup)) {
                        keyup(e.keyCode);
                    }
                });
            }
            // Redraw will be executed many times
            function redraw() {
                // Clear the canvas
                context.clearRect(0, 0, canvas.width, canvas.height);

                context.globalAlpha = 1;
                context.font = "10px Arial";
                context.fillStyle = "blue";
                context.textBaseline = "top";

                // Call draw function from game.js
                draw();


                // Call redraw after some time (the browser decides this time)
                reqAnimationFrame(redraw);
            };

            function initGlobalVariables() {
                updateTime = 10;
                mouseX = 0;
                mouseX = 0;
                mouseY = 0;
                key_left = 37;
                key_up = 38;
                key_right = 39;
                key_down = 40;
                key_a = 65;
                key_z = 90;
                isKeyPressed = new Array(256).fill(0);
            }
            function drawError() {
                // Draw error text on canvas 
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.globalAlpha = 1;
                context.fillStyle = "#FF0000";
                context.font = "20px Arial";
                context.fillText("Press <F12> for error info!", 40, 40);
            }
            // Starts game when body element is loaded
            function onBodyLoad() {

                initGlobalVariables();

                getCanvas();

                attachEvents();

                if (!isFunction(draw)) {
                    // Draw error on canvas when function draw is not in game.js
                    drawError();
                    throw new TypeError("draw is not a function (in game.js)");
                }

                // Call programmers init function if it exists in game.js
                if (isFunction(init)) {
                    init();
                }

                if (!isFunction(update)) {
                    // Draw error on canvas when function update is not in game.js
                    drawError();
                    throw new TypeError("update is not a function (in game.js)");
                }
                redraw();
                setInterval(update, updateTime);
            }
        </script>
        <!-- user's game file -->
        <script src="class.js"></script>
        <script src="game.js"></script>
    </canvas>
</body>

</html>